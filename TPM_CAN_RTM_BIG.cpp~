#include "headers.h"
#include <odb_API.h>


using namespace std;

int ABQmain(int argc,char *argv[])
{


//values to be changed as input 
double numberofloadsteps=5.0;
double ltwocurrentfi=10000.0;
double ltwoinitialfi=10000.0;

ifstream nodes_infile(argv[1]);
ifstream nodes_infile_alloc(argv[1]);
int numberofnodes;
Node *nodes; 

ifstream elements_infile(argv[1]);
ifstream elements_infile_alloc(argv[1]);
int numberofelements;
Element* elements;

//files of boundary conditions 
ifstream natural_bc("natural_bc.inp");
ifstream neumann_bc("neumann_bc.inp");
//debugfile 
ofstream debugfile("debugfile.deb");


//Global declerations, thought initially as dense matrices 
int **eft;
double** Kglobal;
double** Kglobal_copy;
double* force;
double* force_constant;
double* df;
double* du;
double* du_prev;
double *fi;

//counting 
node_counter(nodes_infile,numberofnodes);
element_counter(elements_infile,numberofelements);


//allocation and initialization of the parameters 
nodes=new Node[numberofnodes];
elements=new Element[numberofelements];

node_allocater(nodes,nodes_infile_alloc,numberofnodes);
element_allocater(nodes, elements, elements_infile_alloc, numberofnodes, numberofelements);

//allocation of the global vectors 
eft=new int*[24];
Kglobal=new double*[3*numberofnodes];
Kglobal_copy=new double*[3*numberofnodes];
force=new double[3*numberofnodes];
force_constant=new double[3*numberofnodes];
df=new double[3*numberofnodes];
du=new double[3*numberofnodes];
du_prev=new double[3*numberofnodes];
fi=new double[3*numberofnodes];
for(int i=0;i<24;i++)
eft[i]=new int[numberofelements];
for(int i=0;i<3*numberofnodes;i++)
{
Kglobal[i]=new double[3*numberofnodes];
Kglobal_copy[i]=new double[3*numberofnodes];
for(int j=0;j<3*numberofnodes;j++)
Kglobal[i][j]=0.0;
force[i]=0.0;
force_constant[i]=0.0;
du_prev[i]=0.0;
du[i]=0.0;
}

apply_natural_bc(nodes,natural_bc,numberofnodes);
apply_neumann_bc(force,nodes,neumann_bc,numberofnodes);
eftable(elements,eft,debugfile,numberofelements);

for(double l=0;l<numberofloadsteps;l++)
{
int numberofinneriterations=0;
ltwocurrentfi=100000.0;
ltwoinitialfi=100000.0;
double errormeasure;
initialize(nodes,df,fi,force,force_constant,numberofloadsteps,l,debugfile,numberofnodes);
cout<<'\t'<<"step "<<l<<endl;
debugfile<<'\t'<<"step "<<l<<endl;
do
{
K_global(nodes,elements,numberofelements,debugfile);
K_assembly(elements,Kglobal,Kglobal_copy,eft,debugfile,numberofnodes,numberofelements);
Kglobal_reducer(nodes,Kglobal,fi,debugfile,numberofnodes);
gausselim(fi,Kglobal,3*numberofnodes,debugfile,nodes,du);
//fullincrementalforcevector(nodes,df,du,Kglobal_copy,numberofinneriterations,ltwoinitialfi,l,debugfile,numberofnodes);
update_fi(nodes,elements,fi,force,df,du,numberofloadsteps,l,ltwocurrentfi,debugfile,numberofnodes,numberofelements);
if(numberofinneriterations<1.0)
du_copy(fi,du_prev,debugfile,numberofnodes);
errormeasure=error_indu(fi,du_prev,debugfile,numberofnodes);


//if(numberofinneriterations<1.0)
//du_copy(fi,du_prev,debugfile,numberofnodes);
//errormeasure=error_indu(fi,du_prev,debugfile,numberofnodes);
cout<<"iteration"<<numberofinneriterations<<'\t'<<errormeasure<<endl; 
debugfile<<'\t'<<"iteration"<<numberofinneriterations<<'\t'<<errormeasure<<endl; 
//if(numberofinneriterations>=25)
//errormeasure=0.05; 
numberofinneriterations++;
}
while(errormeasure>0.01 && numberofinneriterations<=25.0);


//if(l==0)
//result_writer(nodes,elements,numberofnodes,numberofelements);

//while(numberofinneriterations<5);
numberofinneriterations=0;
}

result_writer(nodes,elements,numberofnodes,numberofelements);
odb_result_writer(nodes,elements,numberofnodes,numberofelements);




//cout<<"The file name you have given: "<<argv[1]<<endl;
return 0;
};




void node_allocater(Node _nodes[], ifstream &_nodes_infile, int &_numberofnodes)
{

//Start allocating 
for(int n=0;n<_numberofnodes;n++)
{
_nodes[n].X=new double[3];
_nodes[n].u=new double[3];
_nodes[n].natural_bc=new int[3];
_nodes[n].neumann_bc=new int[3];
}
//End Allocating 


char current_line[256];
_nodes_infile.getline(current_line,256);
int condition=0;
while(condition==0)
{
_nodes_infile.getline(current_line,256);
if(current_line[1]=='N' && current_line[2]=='O' && current_line[3]=='D' && current_line[4]=='E')
condition=1; 
}

for(int n=0;n<_numberofnodes;n++)
{
char comma;
_nodes_infile>>_nodes[n].nodelabel; 
_nodes_infile>>comma;
for(int i=0;i<2;i++)
{
_nodes_infile>>_nodes[n].X[i]; 
_nodes_infile>>comma;
}
_nodes_infile>>_nodes[n].X[2]; 
for(int i=0;i<3;i++)
{
_nodes[n].u[i]=0.0;
_nodes[n].natural_bc[i]=0;
_nodes[n].neumann_bc[i]=0;
}

}

/*
for(int n=0;n<_numberofnodes;n++)
{
cout<<_nodes[n].nodelabel<<'\t';
cout<<_nodes[n].X[0]<<'\t';
cout<<_nodes[n].X[1]<<'\t';
cout<<_nodes[n].X[2]<<endl;
}
*/
}

void element_allocater(Node _nodes[], Element _elements[], ifstream &_elements_infile, int &_numberofnodes, int &_numberofelements)
{

//Start allocating 
for(int e=0;e<_numberofelements;e++)
{
_elements[e].conname=new int[8];
_elements[e].connid=new int[8];
_elements[e].elementnodes=new Node[8];
}
//End Allocating 


char current_line[256];
_elements_infile.getline(current_line,256);
int condition=0;
while(condition==0)
{
_elements_infile.getline(current_line,256);
//cout<<current_line<<endl;
if(current_line[1]=='E' && current_line[2]=='L' && current_line[3]=='E' && current_line[4]=='M' 
&& current_line[5]=='E' && current_line[6]=='N' && current_line[7]=='T')
condition=1; 
}

for(int e=0;e<_numberofelements;e++)
{
char comma;
_elements_infile>>_elements[e].elementlabel; 
_elements_infile>>comma;
for(int i=0;i<7;i++)
{
_elements_infile>>_elements[e].conname[i]; 
_elements_infile>>comma;
}
_elements_infile>>_elements[e].conname[7]; 

//assignment of the connectivity id 
for(int n=0;n<_numberofnodes;n++)
for(int i=0;i<8;i++)
if(_nodes[n].nodelabel==_elements[e].conname[i])
_elements[e].connid[i]=n;

}

/*
for(int e=0;e<_numberofelements;e++)
{
cout<<_elements[e].elementlabel<<'\t';
for(int i=0;i<7;i++)
cout<<_elements[e].conname[i]<<'\t';
cout<<_elements[e].conname[8]<<endl;
}
*/
}



//Strain-Displacement Matrix at a specific gauss point 
void Grad_at_Gauss(Node _nodes[],
	           Element _elements[],
	           double _ksi, double _eta, double _zeta,
                   double &_detj,
                   int _currentelement,
	           double B[][24], //Strain displacement matrix 
		   double F[], //deformation gradient 
                   ofstream &_debugfile
		   )
{
double jacob[3][3];
double detj; 
double shapederivative[9][24];
double modifiedinversejacob_B[6][9];
double modifiedinversejacob_F[9][9];
double Finterpolator[9][24];
double Gradu[9];
double GraduT_tensor[3][3];
double BLin[6][24];


for(int i=0;i<6;i++)
for(int j=0;j<24;j++)
{
B[i][j]=0.0;
//With BLin it is not necessarily meant the Linear Strain displacement matrix 
//It represents only the previous multiplication of the Nonlinear strain displacement matrix 
BLin[i][j]=0.0; 
}
for(int i=0;i<9;i++)
for(int j=0;j<24;j++)
{
shapederivative[i][j]=0.0;
Finterpolator[i][j]=0.0;
Gradu[i]=0.0;
}
for(int i=0;i<6;i++)
for(int j=0;j<9;j++)
modifiedinversejacob_B[i][j]=0.0;


for(int i=0;i<9;i++)
for(int j=0;j<9;j++)
modifiedinversejacob_F[i][j]=0.0;


shapederivative[0][0]=shapederivative[3][1]=shapederivative[6][2]=-0.125*(1.0-_eta)*(1.0-_zeta);
shapederivative[1][0]=shapederivative[4][1]=shapederivative[7][2]=-0.125*(1.0-_ksi)*(1.0-_zeta);
shapederivative[2][0]=shapederivative[5][1]=shapederivative[8][2]=-0.125*(1.0-_ksi)*(1.0-_eta);
//2 three columns 
shapederivative[0][3]=shapederivative[3][4]=shapederivative[6][5]=0.125*(1.0-_eta)*(1.0-_zeta);
shapederivative[1][3]=shapederivative[4][4]=shapederivative[7][5]=-0.125*(1.0+_ksi)*(1.0-_zeta);
shapederivative[2][3]=shapederivative[5][4]=shapederivative[8][5]=-0.125*(1.0+_ksi)*(1.0-_eta);
//3 three columns 
shapederivative[0][6]=shapederivative[3][7]=shapederivative[6][8]=0.125*(1.0+_eta)*(1.0-_zeta);
shapederivative[1][6]=shapederivative[4][7]=shapederivative[7][8]=0.125*(1.0+_ksi)*(1.0-_zeta);
shapederivative[2][6]=shapederivative[5][7]=shapederivative[8][8]=-0.125*(1.0+_ksi)*(1.0+_eta);
//4 three columns 
shapederivative[0][9]=shapederivative[3][10]=shapederivative[6][11]=-0.125*(1.0+_eta)*(1.0-_zeta);
shapederivative[1][9]=shapederivative[4][10]=shapederivative[7][11]=0.125*(1.0-_ksi)*(1.0-_zeta);
shapederivative[2][9]=shapederivative[5][10]=shapederivative[8][11]=-0.125*(1.0-_ksi)*(1.0+_eta);
//5 three columns 
shapederivative[0][12]=shapederivative[3][13]=shapederivative[6][14]=-0.125*(1.0-_eta)*(1.0+_zeta);
shapederivative[1][12]=shapederivative[4][13]=shapederivative[7][14]=-0.125*(1.0-_ksi)*(1.0+_zeta);
shapederivative[2][12]=shapederivative[5][13]=shapederivative[8][14]=0.125*(1.0-_ksi)*(1.0-_eta);
//6 three columns 
shapederivative[0][15]=shapederivative[3][16]=shapederivative[6][17]=0.125*(1.0-_eta)*(1.0+_zeta);
shapederivative[1][15]=shapederivative[4][16]=shapederivative[7][17]=-0.125*(1.0+_ksi)*(1.0+_zeta);
shapederivative[2][15]=shapederivative[5][16]=shapederivative[8][17]=0.125*(1.0+_ksi)*(1.0-_eta);
//7 three columns 
shapederivative[0][18]=shapederivative[3][19]=shapederivative[6][20]=0.125*(1.0+_eta)*(1.0+_zeta);
shapederivative[1][18]=shapederivative[4][19]=shapederivative[7][20]=0.125*(1.0+_ksi)*(1.0+_zeta);
shapederivative[2][18]=shapederivative[5][19]=shapederivative[8][20]=0.125*(1.0+_ksi)*(1.0+_eta);
//8 three columns 
shapederivative[0][21]=shapederivative[3][22]=shapederivative[6][23]=-0.125*(1.0+_eta)*(1.0+_zeta);
shapederivative[1][21]=shapederivative[4][22]=shapederivative[7][23]=0.125*(1.0-_ksi)*(1.0+_zeta);
shapederivative[2][21]=shapederivative[5][22]=shapederivative[8][23]=0.125*(1.0-_ksi)*(1.0+_eta);

for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
jacob[i][j]=0.0; 

//CAUTION! MOST PROBABLY THE TOTAL DEFORMATION AND THUS THE CURRENT COORDINATES HAVE TO BE USED HERE ! 
for(int i=0;i<3;i++)
for(int j=0;j<8;j++)
{
jacob[0][i]=jacob[0][i]+shapederivative[i][j*3]*_nodes[_elements[_currentelement].connid[j]].X[0];
jacob[1][i]=jacob[1][i]+shapederivative[i][j*3]*_nodes[_elements[_currentelement].connid[j]].X[1];
jacob[2][i]=jacob[2][i]+shapederivative[i][j*3]*_nodes[_elements[_currentelement].connid[j]].X[2];
}

detj=det(jacob);
_detj=detj;
modifiedinversejacob_B[0][0]=modifiedinversejacob_B[3][3]=modifiedinversejacob_B[5][6]=(jacob[1][1]*jacob[2][2]-jacob[2][1]*jacob[1][2])/detj;
modifiedinversejacob_B[0][1]=modifiedinversejacob_B[3][4]=modifiedinversejacob_B[5][7]=(jacob[1][2]*jacob[2][0]-jacob[2][2]*jacob[1][0])/detj;
modifiedinversejacob_B[0][2]=modifiedinversejacob_B[3][5]=modifiedinversejacob_B[5][8]=(jacob[1][0]*jacob[2][1]-jacob[2][0]*jacob[1][1])/detj;

modifiedinversejacob_B[1][3]=modifiedinversejacob_B[3][0]=modifiedinversejacob_B[4][6]=(jacob[0][2]*jacob[2][1]-jacob[2][2]*jacob[0][1])/detj;
modifiedinversejacob_B[1][4]=modifiedinversejacob_B[3][1]=modifiedinversejacob_B[4][7]=(jacob[0][0]*jacob[2][2]-jacob[2][0]*jacob[0][2])/detj;
modifiedinversejacob_B[1][5]=modifiedinversejacob_B[3][2]=modifiedinversejacob_B[4][8]=(jacob[0][1]*jacob[2][0]-jacob[2][1]*jacob[0][0])/detj;

modifiedinversejacob_B[2][6]=modifiedinversejacob_B[4][3]=modifiedinversejacob_B[5][0]=(jacob[0][1]*jacob[1][2]-jacob[1][1]*jacob[0][2])/detj;
modifiedinversejacob_B[2][7]=modifiedinversejacob_B[4][4]=modifiedinversejacob_B[5][1]=(jacob[0][2]*jacob[1][0]-jacob[1][2]*jacob[0][0])/detj;
modifiedinversejacob_B[2][8]=modifiedinversejacob_B[4][5]=modifiedinversejacob_B[5][2]=(jacob[0][0]*jacob[1][1]-jacob[1][0]*jacob[0][1])/detj;







modifiedinversejacob_F[0][0]=modifiedinversejacob_F[3][3]=modifiedinversejacob_F[6][6]=(jacob[1][1]*jacob[2][2]-jacob[2][1]*jacob[1][2])/detj;
modifiedinversejacob_F[0][1]=modifiedinversejacob_F[3][4]=modifiedinversejacob_F[6][7]=(jacob[1][2]*jacob[2][0]-jacob[2][2]*jacob[1][0])/detj;
modifiedinversejacob_F[0][2]=modifiedinversejacob_F[3][5]=modifiedinversejacob_F[6][8]=(jacob[1][0]*jacob[2][1]-jacob[2][0]*jacob[1][1])/detj;

modifiedinversejacob_F[1][0]=modifiedinversejacob_F[4][3]=modifiedinversejacob_F[7][6]=(jacob[0][2]*jacob[2][1]-jacob[2][2]*jacob[0][1])/detj;
modifiedinversejacob_F[1][1]=modifiedinversejacob_F[4][4]=modifiedinversejacob_F[7][7]=(jacob[0][0]*jacob[2][2]-jacob[2][0]*jacob[0][2])/detj;
modifiedinversejacob_F[1][2]=modifiedinversejacob_F[4][5]=modifiedinversejacob_F[7][8]=(jacob[0][1]*jacob[2][0]-jacob[2][1]*jacob[0][0])/detj;


modifiedinversejacob_F[2][0]=modifiedinversejacob_F[5][3]=modifiedinversejacob_F[8][6]=(jacob[0][1]*jacob[1][2]-jacob[1][1]*jacob[0][2])/detj;
modifiedinversejacob_F[2][1]=modifiedinversejacob_F[5][4]=modifiedinversejacob_F[8][7]=(jacob[0][2]*jacob[1][0]-jacob[1][2]*jacob[0][0])/detj;
modifiedinversejacob_F[2][2]=modifiedinversejacob_F[5][5]=modifiedinversejacob_F[8][8]=(jacob[0][0]*jacob[1][1]-jacob[1][0]*jacob[0][1])/detj;

/*
if(_currentelement==0)
_debugfile<<"det J: "<<detj<<endl;


if(_currentelement==0)
{
_debugfile<<"Something "<<_currentelement<<endl;
for(int i=0;i<3;i++)
for(int k=0;k<3;k++)
_debugfile<<jacob[i][k]<<setw(10)<<endl;
}
*/

for(int i=0;i<9;i++)
for(int k=0;k<24;k++)
for(int j=0;j<9;j++)
Finterpolator[i][k]=Finterpolator[i][k]+modifiedinversejacob_F[i][j]*shapederivative[j][k];





for(int i=0;i<9;i++)
for(int k=0;k<24;k++)
Gradu[i]=Gradu[i]+Finterpolator[i][k]*_nodes[_elements[_currentelement].connid[k/3]].u[k%3];



for(int i=0;i<9;i++)
{
F[i]=Gradu[i];
if(i==0 || i==4 || i==8)
F[i]=F[i]+1.0;  
}


for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
GraduT_tensor[j][i]=F[i*3+j];


for(int i=0;i<6;i++)
for(int k=0;k<24;k++)
for(int j=0;j<9;j++)
BLin[i][k]=BLin[i][k]+modifiedinversejacob_B[i][j]*shapederivative[j][k];




for(int i=0;i<6;i++)
for(int k=0;k<24;k++)
for(int j=0;j<24;j++)
B[i][k]=B[i][k]+BLin[i][j]*GraduT_tensor[j%3][k%3]*cronecker(k/3,j/3);

/*
if(_currentelement==0)
{
_debugfile<<"Something "<<_currentelement<<endl;
for(int i=0;i<3;i++)
{
for(int k=0;k<3;k++)
_debugfile<<GraduT_tensor[k][i]<<setw(10);
_debugfile<<endl;
}
}
*/

/*
if(_currentelement==0)
{
_debugfile<<"Something "<<_currentelement<<endl;
for(int i=0;i<24;i++)
{
for(int k=0;k<24;k++)
_debugfile<<GraduT_tensor[i%3][k%3]*cronecker(i/3,k/3)<<setw(10);
_debugfile<<endl;
}
}
*/
};


void Elasticity_at_Gauss(double D[][6],  
		         double F[], //deformation gradient 
			 double S[],
                         ofstream &_debugfile)
{
double Ftens[3][3];
double FtensT[3][3];
double FtensInv[3][3];
double Cauchy[3][3]; //Cauchy-Green Strain Tensor 
double gammablk=100; //gamma coefficient for the bulk energy 
double beta=4.5; //beta coefficient for something else 
double c[3][3][3][3];  //constitutive tensor in tensor notation 
double C[3][3][3][3]; //bulk constitutive tensor 
double E=210000.0;
double v=0.3;
double lambda=E*v/(1.0+v)/(1.0-2.0*v);
double Mu=E*(1.0-v)/(1.0+v)/(1.0-2.0*v);

Ftens[0][0]=F[0];
Ftens[0][1]=F[3];
Ftens[0][2]=F[6];
Ftens[1][0]=F[1];
Ftens[1][1]=F[4];
Ftens[1][2]=F[7];
Ftens[2][0]=F[2];
Ftens[2][1]=F[5];
Ftens[2][2]=F[8];

transpose(Ftens,FtensT); 
matrix_product(FtensT,Ftens,Cauchy); 
double Ithree=det(Cauchy); 
double Ione=trace(Cauchy); 
inverse(Ftens,FtensInv);
double detF=det(Ftens);


for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
for(int k=0;k<3;k++)
for(int l=0;l<3;l++)
{
c[i][j][k][l]=(lambda*((2.0*detF-1.0)*cronecker(i,j)*cronecker(k,l)-2.0*symmetry_tensor(i,j,k,l)*(detF-1.0))+2.0*Mu/detF*symmetry_tensor(i,j,k,l));
//coefficient 4 is for the cauchy to green-lagrange strain tensor conversion 
}

for(int I=0;I<3;I++)
for(int J=0;J<3;J++)
for(int K=0;K<3;K++)
for(int L=0;L<3;L++)
C[I][J][K][L]=0.0;

for(int I=0;I<3;I++)
for(int J=0;J<3;J++)
for(int K=0;K<3;K++)
for(int L=0;L<3;L++)
for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
for(int k=0;k<3;k++)
for(int l=0;l<3;l++)
{
C[I][J][K][L]=C[I][J][K][L]+FtensInv[I][i]*FtensInv[J][j]*c[i][j][k][l]*FtensInv[K][k]*FtensInv[L][l]*detF;
}

/*
for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
for(int k=0;k<3;k++)
for(int l=0;l<3;l++)
{
cbulk[i][j][k][l]=4*gammablk*beta*pow(Ithree,-1.0*beta)*cronecker(i,j)*cronecker(k,l)
                 +4*gammablk*pow(Ithree,-1.0*beta)*symmetry_tensor(i,j,k,l);
c[i][j][k][l]=+cbulk[i][j][k][l]+c[i][j][k][l]; 
}
*/  
D[0][0]=C[0][0][0][0];
D[0][1]=C[0][0][1][1];
D[0][2]=C[0][0][2][2];
D[0][3]=C[0][0][0][1];
D[0][4]=C[0][0][1][2];
D[0][5]=C[0][0][2][0];
 
D[1][0]=C[1][1][0][0];
D[1][1]=C[1][1][1][1];
D[1][2]=C[1][1][2][2];
D[1][3]=C[1][1][0][1];
D[1][4]=C[1][1][1][2];
D[1][5]=C[1][1][2][0];

D[2][0]=C[2][2][0][0];
D[2][1]=C[2][2][1][1];
D[2][2]=C[2][2][2][2];
D[2][3]=C[2][2][0][1];
D[2][4]=C[2][2][1][2];
D[2][5]=C[2][2][2][0];

D[3][0]=C[0][1][0][0];
D[3][1]=C[0][1][1][1];
D[3][2]=C[0][1][2][2];
D[3][3]=C[0][1][0][1];
D[3][4]=C[0][1][1][2];
D[3][5]=C[0][1][2][0];

D[4][0]=C[1][2][0][0];
D[4][1]=C[1][2][1][1];
D[4][2]=C[1][2][2][2];
D[4][3]=C[1][2][0][1];
D[4][4]=C[1][2][1][2];
D[4][5]=C[1][2][2][0];

D[5][0]=C[2][0][0][0];
D[5][1]=C[2][0][1][1];
D[5][2]=C[2][0][2][2];
D[5][3]=C[2][0][0][1];
D[5][4]=C[2][0][1][2];
D[5][5]=C[2][0][2][0];

/*
_debugfile<<"Something "<<endl;
for(int i=0;i<6;i++)
for(int j=0;j<6;j++)
_debugfile<<D[i][j]<<setw(10);
_debugfile<<endl;
*/

//computation of the stress
double cauchy_stress[3][3];
double finger[3][3];
double Stens[3][3];

for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
{
cauchy_stress[i][j]=0.0;
Stens[i][j]=0.0;
}
matrix_product(Ftens,FtensT,finger);

for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
cauchy_stress[i][j]=(cauchy_stress[i][j]+lambda*(detF-1.0)*cronecker(i,j)+Mu/detF*(finger[i][j]-cronecker(i,j)));
//coefficient 2 is for the cauchy to green lagrange strain tensor conversion 
for(int I=0;I<3;I++)
for(int J=0;J<3;J++)
for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
Stens[I][J]=Stens[I][J]+detF*FtensInv[i][I]*cauchy_stress[i][j]*FtensInv[j][J];

S[0]=Stens[0][0];
S[1]=Stens[1][1];
S[2]=Stens[2][2];
S[3]=Stens[0][1];
S[4]=Stens[1][2];
S[5]=Stens[2][0];


};





void K_element(Node _nodes[],
	       Element _elements[],
               int _currentelement,
               ofstream &_debugfile)
{
double Kgeo[24][24];
for(int i=0;i<24;i++)
for(int j=0;j<24;j++)
Kgeo[i][j]=0.0;
for(int i=0;i<24;i++)
for(int j=0;j<24;j++)
_elements[_currentelement].Kelem[i][j]=0.0; 

//call for the standard gauss points 
for(double g1=-1.0;g1<2.0;g1=g1+2.0)
for(double g2=-1.0;g2<2.0;g2=g2+2.0)
for(double g3=-1.0;g3<2.0;g3=g3+2.0)
{
//local declerations 
double detj=0.0;
double B[6][24];//strain displacement matrix at the gauss point
double F[9];//deformation gradient at the gauss point 
double D[6][6];//elasticity matrix at the gauss point
double Bt_dot_D[24][6];
double Bt[24][6];
double S[6];

//computation of the noonlinear strain-displacement matrix and the deformation gradient at the gauss points
Grad_at_Gauss(_nodes,_elements,g1*1.0/sqrt(3),g2*1.0/sqrt(3),g3*1.0/sqrt(3),detj,_currentelement,B,F,_debugfile);
//the material coefficients are defined inside of the function beneath
Elasticity_at_Gauss(D,F,S,_debugfile); //for the time being this function is independent of the space
//Contribution of the geometric stiffness 
K_gauss_geometrical(_nodes,_elements,g1*1.0/sqrt(3),g2*1.0/sqrt(3),g3*1.0/sqrt(3),B,D,F,S,Kgeo,detj,_currentelement,_debugfile);//TO BE FINISHED 


for(int i=0;i<24;i++)
for(int j=0;j<6;j++)
Bt[i][j]=B[j][i];


for(int i=0;i<24;i++)
for(int j=0;j<6;j++)
Bt_dot_D[i][j]=0.0; 

for(int i=0;i<24;i++)
for(int k=0;k<6;k++)
for(int j=0;j<6;j++)
Bt_dot_D[i][k]=Bt_dot_D[i][k]+Bt[i][j]*D[j][k]; 

for(int i=0;i<24;i++)
for(int k=0;k<24;k++)
for(int j=0;j<6;j++)
_elements[_currentelement].Kelem[i][k]=_elements[_currentelement].Kelem[i][k]+Bt_dot_D[i][j]*B[j][k];//*detj;



for(int i=0;i<24;i++)
for(int j=0;j<24;j++)
Kgeo[i][j]=0.0;

for(int i=0;i<24;i++)
for(int k=0;k<24;k++)
_elements[_currentelement].Kelem[i][k]=_elements[_currentelement].Kelem[i][k]+Kgeo[i][k];




/*
if(_currentelement==0)
{
_debugfile<<"Something "<<_currentelement<<endl;
for(int i=0;i<24;i++)
for(int k=0;k<24;k++)
_debugfile<<Kelem[i][k]<<setw(10)<<endl;

}

*/



}



/*
if(_currentelement==0)
{
_debugfile<<"Something "<<_currentelement<<endl;
for(int i=0;i<24;i++)
for(int k=0;k<24;k++)
_debugfile<<_elements[_currentelement].Kelem[i][k]<<setw(10)<<endl;
}
*/


/*
_debugfile<<"Element stiffness "<<_currentelement<<endl;
for(int i=0;i<24;i++)
for(int k=0;k<24;k++)
_debugfile<<_elements[_currentelement].Kelem[i][k]<<setw(10)<<endl;
*/
};


void K_gauss_geometrical(Node _nodes[],
	                 Element _elements[],
	                 double _ksi, double _eta, double _zeta,
			 double B[][24], //this is necessary for the computation of the green-lagrange strain tensor and the second piola kirchoff stress tensor 
			 double D[][6], //this is necessary for the computation of the second piola kirchoff stress tensor 
			 double F[],
			 double S[],
			 double _Kgeo[][24],//the geometrical stiffness matrix to be passed 
			 double& detj,
                         int _currentelement,
                         ofstream &_debugfile)
{
double dNdksi[24]; 
double inversejacob[24][24]; 
double dNdX[24]; 
double jacob[3][3]; 
//double E[6]; //Green Lagrange Strain Tensor in Vector format 
//double S[6]; //Second Piola-Krichoff Material in Vector format 
double Ftens[3][3];
double FtensT[3][3];
double Etens[3][3];

/*
for(int i=0;i<6;i++)
{
E[i]=0.0;
S[i]=0.0;
}
*/
dNdksi[0]=-0.125*(1.0-_eta)*(1.0-_zeta);
dNdksi[1]=-0.125*(1.0-_ksi)*(1.0-_zeta);
dNdksi[2]=-0.125*(1.0-_ksi)*(1.0-_eta);


dNdksi[3]=0.125*(1.0-_eta)*(1.0-_zeta);
dNdksi[4]=-0.125*(1.0+_ksi)*(1.0-_zeta);
dNdksi[5]=-0.125*(1.0+_ksi)*(1.0-_eta);


dNdksi[6]=0.125*(1.0+_eta)*(1.0-_zeta);
dNdksi[7]=0.125*(1.0+_ksi)*(1.0-_zeta);
dNdksi[8]=-0.125*(1.0+_ksi)*(1.0+_eta);

dNdksi[9]=-0.125*(1.0+_eta)*(1.0-_zeta);
dNdksi[10]=0.125*(1.0-_ksi)*(1.0-_zeta);
dNdksi[11]=-0.125*(1.0-_ksi)*(1.0+_eta);

dNdksi[12]=-0.125*(1.0-_eta)*(1.0+_zeta);
dNdksi[13]=-0.125*(1.0-_ksi)*(1.0+_zeta);
dNdksi[14]=0.125*(1.0-_ksi)*(1.0-_eta);

dNdksi[15]=0.125*(1.0-_eta)*(1.0+_zeta);
dNdksi[16]=-0.125*(1.0+_ksi)*(1.0+_zeta);
dNdksi[17]=0.125*(1.0+_ksi)*(1.0-_eta);

dNdksi[18]=0.125*(1.0+_eta)*(1.0+_zeta);
dNdksi[19]=0.125*(1.0+_ksi)*(1.0+_zeta);
dNdksi[20]=0.125*(1.0+_ksi)*(1.0+_eta);

dNdksi[21]=-0.125*(1.0+_eta)*(1.0+_zeta);
dNdksi[22]=0.125*(1.0-_ksi)*(1.0+_zeta);
dNdksi[23]=0.125*(1.0-_ksi)*(1.0+_eta);




for(int i=0;i<24;i++)
{
for(int j=0;j<24;j++)
inversejacob[i][j]=0.0; 
dNdX[i]=0.0; 
}


for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
jacob[i][j]=0.0;


for(int i=0;i<3;i++) // row label 
for(int j=0;j<8;j++) 
{
jacob[i][0]=jacob[i][0]+dNdksi[j*3+i]*_nodes[_elements[_currentelement].connid[j]].X[0];
jacob[i][1]=jacob[i][1]+dNdksi[j*3+i]*_nodes[_elements[_currentelement].connid[j]].X[1];
jacob[i][2]=jacob[i][2]+dNdksi[j*3+i]*_nodes[_elements[_currentelement].connid[j]].X[2];
}

detj=jacob[0][0]*(jacob[1][1]*jacob[2][2]-jacob[2][1]*jacob[1][2])-
     jacob[0][1]*(jacob[1][0]*jacob[2][2]-jacob[2][0]*jacob[1][2])+
     jacob[0][2]*(jacob[1][0]*jacob[2][1]-jacob[2][0]*jacob[1][1]);


inversejacob[0][0]=inversejacob[3][3]=inversejacob[6][6]=inversejacob[9][9]=inversejacob[12][12]=inversejacob[15][15]=inversejacob[18][18]=inversejacob[21][21]=(jacob[1][1]*jacob[2][2]-jacob[2][1]*jacob[1][2])/detj;
inversejacob[0][1]=inversejacob[3][4]=inversejacob[6][7]=inversejacob[9][10]=inversejacob[12][13]=inversejacob[15][16]=inversejacob[18][19]=inversejacob[21][22]=(jacob[0][2]*jacob[2][1]-jacob[2][2]*jacob[0][1])/detj;
inversejacob[0][2]=inversejacob[3][5]=inversejacob[6][8]=inversejacob[9][11]=inversejacob[12][14]=inversejacob[15][17]=inversejacob[18][20]=inversejacob[21][23]=(jacob[0][1]*jacob[1][2]-jacob[1][1]*jacob[0][2])/detj; 

inversejacob[1][0]=inversejacob[4][3]=inversejacob[7][6]=inversejacob[10][9]=inversejacob[13][12]=inversejacob[16][15]=inversejacob[19][18]=inversejacob[22][21]=(jacob[1][2]*jacob[2][0]-jacob[2][2]*jacob[1][0])/detj;
inversejacob[1][1]=inversejacob[4][4]=inversejacob[7][7]=inversejacob[10][10]=inversejacob[13][13]=inversejacob[16][16]=inversejacob[19][19]=inversejacob[22][22]=(jacob[0][0]*jacob[2][2]-jacob[2][0]*jacob[0][2])/detj;
inversejacob[1][2]=inversejacob[4][5]=inversejacob[7][8]=inversejacob[10][11]=inversejacob[13][14]=inversejacob[16][17]=inversejacob[19][20]=inversejacob[22][23]=(jacob[0][2]*jacob[1][0]-jacob[1][2]*jacob[0][0])/detj;

inversejacob[2][0]=inversejacob[5][3]=inversejacob[8][6]=inversejacob[11][9]=inversejacob[14][12]=inversejacob[17][15]=inversejacob[20][18]=inversejacob[23][21]=(jacob[1][0]*jacob[2][1]-jacob[2][0]*jacob[1][1])/detj;
inversejacob[2][1]=inversejacob[5][4]=inversejacob[8][7]=inversejacob[11][10]=inversejacob[14][13]=inversejacob[17][16]=inversejacob[20][19]=inversejacob[23][22]=(jacob[0][1]*jacob[2][0]-jacob[2][1]*jacob[0][0])/detj;
inversejacob[2][2]=inversejacob[5][5]=inversejacob[8][8]=inversejacob[11][11]=inversejacob[14][14]=inversejacob[17][17]=inversejacob[20][20]=inversejacob[23][23]=(jacob[0][0]*jacob[1][1]-jacob[1][0]*jacob[0][1])/detj;


for(int i=0;i<24;i++)
for(int j=0;j<24;j++)
dNdX[i]=dNdX[i]+inversejacob[i][j]*dNdksi[j];


/*
for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
FtensT[i][j]=F[i*3+j];

for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
Ftens[i][j]=FtensT[j][i];

matrix_product(FtensT,Ftens,Etens);


for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
Etens[i][j]=Etens[i][j]-cronecker(i,j);

for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
Etens[i][j]=0.5*Etens[i][j];

for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
E[i+j*3]=Etens[i][j];


for(int i=0;i<6;i++)
for(int j=0;j<6;j++)
S[i]=S[i]+D[i][j]*E[j];
*/


//CAUTION: IT HAS TO BE CHECKED IF THE GEOMETRICAL STIFFNESS MATRIX HAS TO BE 
//INITIALIZED AS ZERO BEFORE THE CALL OF THIS FUNCTION
//,x: i or j 
//,y: i+1 or j+1 
//,z: i+2 or j+2 
for(int i=0;i<24;i++)
for(int j=0;j<24;j++)
{
if(i%3==0 && j%3==0)
_Kgeo[i][j]=_Kgeo[i][j]+
(dNdX[i]*S[0]*dNdX[j]
+dNdX[i+1]*S[1]*dNdX[j+1]
+dNdX[i+2]*S[2]*dNdX[j+2]
+dNdX[i]*S[3]*dNdX[j+1]
+dNdX[i+1]*S[3]*dNdX[j]
+dNdX[i+1]*S[4]*dNdX[j+2]
+dNdX[i+2]*S[4]*dNdX[j+1]
+dNdX[i]*S[5]*dNdX[j+2]
+dNdX[i+2]*S[5]*dNdX[j]);//*detj; 
else if(i%3!=0 && j>0)
_Kgeo[i][j]=_Kgeo[i-1][j-1]; 
}

}

void update_fi(Node nodes[], Element elements[], double fi[], double forcevector[],double incrementalforcevector[], double du[]
			   , double numberofloadsteps, double l,double& ltwo, ofstream& debugfile,int numberofnodes,int numberofelements)
{

double* internalforcevector=new double[3*numberofnodes]; 
for(int i=0;i<3*numberofnodes;i++)
internalforcevector[i]=0.0; 


double Bt_dot_S[24];



for(int e=0;e<numberofelements;e++)
{
for(int i=0;i<24;i++)
Bt_dot_S[i]=0.0; 
for(double g1=-1.0;g1<2.0;g1=g1+2.0)
for(double g2=-1.0;g2<2.0;g2=g2+2.0)
for(double g3=-1.0;g3<2.0;g3=g3+2.0)
{


//local declerations 
double detj=0.0;
double B[6][24];//strain displacement matrix at the gauss point
double F[9];//deformation gradient at the gauss point 
double D[6][6];//elasticity matrix at the gauss point
double Bt[24][6];
double E[6];
double S[6];
double Ftens[3][3];
double FtensT[3][3];
double Etens[3][3];
for(int i=0;i<6;i++)
{
E[i]=0.0;
S[i]=0.0;
}



//computation of the noonlinear strain-displacement matrix and the deformation gradient at the gauss points
Grad_at_Gauss(nodes,elements,g1*1.0/sqrt(3),g2*1.0/sqrt(3),g3*1.0/sqrt(3),detj,e,B,F,debugfile);
//the material coefficients are defined inside of the function beneath
Elasticity_at_Gauss(D,F,S,debugfile); //for the time being this function is independent of the space
//Contribution of the geometric stiffness 
//K_gauss_geometrical(_nodes,_elements,g1*1.0/sqrt(3),g2*1.0/sqrt(3),g3*1.0/sqrt(3),B,D,Kgeo,detj,_currentelement,_debugfile);//TO BE FINISHED 




for(int i=0;i<24;i++)
for(int j=0;j<6;j++)
Bt[i][j]=B[j][i];

for(int i=0;i<24;i++)
for(int j=0;j<6;j++)
Bt_dot_S[i]=Bt_dot_S[i]+Bt[i][j]*S[j];//*detj; 
/*
if(e==0)
{
debugfile<<"Something "<<e<<endl;
for(int j=0;j<24;j++)
debugfile<<Bt_dot_S[j]<<setw(10)<<endl;
}
*/
}
for(int c=0;c<8;c++)
{
if(nodes[elements[e].connid[c]].neumann_bc[0]==1)
internalforcevector[elements[e].connid[c]*3]=internalforcevector[elements[e].connid[c]*3]+Bt_dot_S[c*3]; 
if(nodes[elements[e].connid[c]].neumann_bc[1]==1)
internalforcevector[elements[e].connid[c]*3+1]=internalforcevector[elements[e].connid[c]*3+1]+Bt_dot_S[c*3+1];
if(nodes[elements[e].connid[c]].neumann_bc[2]==1)
internalforcevector[elements[e].connid[c]*3+2]=internalforcevector[elements[e].connid[c]*3+2]+Bt_dot_S[c*3+2]; 
}




}

//debugfile<<"fi"<<setw(35)<<"incrementalforcevector"<<setw(35)<<"internalforcevector"<<setw(20)<<"du"<<endl; 
for(int i=0;i<3*numberofnodes;i++)
{
fi[i]=incrementalforcevector[i]-internalforcevector[i]; 
//debugfile<<fi[i]<<setw(35)<<incrementalforcevector[i]<<setw(35)<<internalforcevector[i]<<setw(20)<<du[i]<<endl; 
}

debugfile<<"internalforce"<<endl;
for(int i=0;i<3*numberofnodes;i++)
if(nodes[i/3].neumann_bc[2]==1 && i%3==2)
debugfile<<internalforcevector[i]<<'\t'; 
debugfile<<endl; 

debugfile<<"externalforce"<<endl;
for(int i=0;i<3*numberofnodes;i++)
if(nodes[i/3].neumann_bc[2]==1 && i%3==2)
debugfile<<incrementalforcevector[i]<<'\t'; 
debugfile<<endl; 

debugfile<<"fi"<<endl;
for(int i=0;i<3*numberofnodes;i++)
if(nodes[i/3].neumann_bc[2]==1 && i%3==2)
debugfile<<fi[i]<<'\t'; 
debugfile<<endl; 

ltwo=eulernorm_residual(fi,numberofnodes); 
}; 


void apply_natural_bc(Node _nodes[],ifstream& _natural_bc,int _numberofnodes)
{
char star='+'; 
int currentnodelabel; 
int currentid; 
do
{
	_natural_bc>>star; 
	_natural_bc.putback(star); 
	_natural_bc>>currentnodelabel; 
for(int n=0;n<_numberofnodes;n++)
if(currentnodelabel==_nodes[n].nodelabel)
currentid=n;

	if(star!='*')
	{
		_natural_bc>>_nodes[currentid].natural_bc[0]; 
		_natural_bc>>_nodes[currentid].natural_bc[1];
		_natural_bc>>_nodes[currentid].natural_bc[2];
	}

}while(star!='*'); 


};  


void apply_neumann_bc(double _force[], Node _nodes[], ifstream& _force_bc, int _numberofnodes)
{

for(int i=0;i<_numberofnodes*3;i++)
_force[i]=0.0; 

char star='+'; 
int currentnodelabel;
int currentid; 
do
{
	_force_bc>>star; 
	_force_bc.putback(star); 
	_force_bc>>currentnodelabel; 
for(int n=0;n<_numberofnodes;n++)
if(currentnodelabel==_nodes[n].nodelabel)
currentid=n;

	if(star!='*')
	{
		_force[currentid*3+0]=-5000.0;
		_nodes[currentid].neumann_bc[0]=1;
	}

}while(star!='*'); 
 }; 



void initialize(Node _nodes[], double _df[],double _fi[], double _force[],double _force_constant[], double _numberofloadsteps, double _l, ofstream& _debugfile, int _numberofnodes)
{
for(int i=0;i<3*_numberofnodes;i++)
{
//if(_l==0)
_df[i]=_force[i]/_numberofloadsteps*(_l+1)+_force_constant[i]; 
_fi[i]=_force[i]/_numberofloadsteps; 
}
/*
if(_l==0)
for(int i=0;i<3*_numberofnodes;i++)
_debugfile<<_df[i]<<endl;
*/
};


void K_global(Node _nodes[],
	      Element _elements[],
	      int _numberofelements,
              ofstream &_debugfile)
{
for(int e=0;e<_numberofelements;e++)
K_element(_nodes,_elements,e,_debugfile);
}; 


void eftable(Element _elements[], int** _eft,ofstream& _debugfile,int _numberofelements)
{
for(int e=0;e<_numberofelements;e++)
for(int c=0;c<8;c++)
{
_eft[3*c][e]=_elements[e].connid[c]*3;
_eft[3*c+1][e]=_elements[e].connid[c]*3+1;
_eft[3*c+2][e]=_elements[e].connid[c]*3+2;
}
/*
debugfile<<"element freedom table:"<<endl;
for(int i=0;i<8;i++)
{
for(int j=0;j<2;j++)
debugfile<<eft[i][j]<<'\t';
debugfile<<endl; 
}
*/ 
};


void K_assembly(Element _elements[], double** _Kglobal, double** _Kglobalcopy, int** _eft,ofstream& _debugfile,int _numberofnodes, int _numberofelements)
{

for(int i=0;i<3*_numberofnodes;i++)
for(int j=0;j<3*_numberofnodes;j++)	
_Kglobal[i][j]=0.0; 	

for(int e=0;e<_numberofelements;e++)
for(int m=0;m<24;m++)
for(int n=0;n<24;n++)
{
_Kglobal[_eft[m][e]][_eft[n][e]]=_Kglobal[_eft[m][e]][_eft[n][e]]+_elements[e].Kelem[m][n]; 
_elements[e].Kelem[m][n]=0.0;
}



for(int i=0;i<3*_numberofnodes;i++)
for(int j=0;j<3*_numberofnodes;j++)
_Kglobalcopy[i][j]=_Kglobal[i][j];
/*
_debugfile<<"Unreduced Global stiffness matrix:"<<endl; 
_debugfile<<setw(10); 
for(int i=0;i<12;i++)
{
for(int j=0;j<12;j++)
_debugfile<<_Kglobal[i][j]<<setw(18); 
_debugfile<<endl; 
}
*/ 
}; 


void Kglobal_reducer(Node _nodes[], double** _Kglobal, double _fi[], ofstream& _debugfile, int _numberofnodes)
{
for(int n=0;n<_numberofnodes;n++)
{
if(_nodes[n].natural_bc[0]==1)
for(int i=0;i<3*_numberofnodes;i++)
{
_Kglobal[n*3][i]=0.0;
_Kglobal[i][n*3]=0.0;
_Kglobal[n*3][n*3]=1.0;
_fi[n*3]=0.0; 
}
//if(_nodes[n].neumann_bc[0]==1)
//_fi[n*3]=0.0;

if(_nodes[n].natural_bc[1]==1)
for(int i=0;i<3*_numberofnodes;i++)
{
_Kglobal[n*3+1][i]=0.0;
_Kglobal[i][n*3+1]=0.0;
_Kglobal[n*3+1][n*3+1]=1.0;
_fi[n*3+1]=0.0; 
}
//if(_nodes[n].neumann_bc[1]==1)
//_fi[n*3+1]=0.0;

if(_nodes[n].natural_bc[2]==1)
for(int i=0;i<3*_numberofnodes;i++)
{
_Kglobal[n*3+2][i]=0.0;
_Kglobal[i][n*3+2]=0.0;
_Kglobal[n*3+2][n*3+2]=1.0;
_fi[n*3+2]=0.0; 
}
//if(_nodes[n].neumann_bc[2]==1)
//_fi[n*3+2]=0.0;

}

/*
_debugfile<<"Reduced Global stiffness matrix:"<<endl; 
_debugfile<<setw(18); 
for(int i=0;i<3*_numberofnodes;i++)
{
for(int j=0;j<3*_numberofnodes;j++)
_debugfile<<_Kglobal[i][j]<<setw(18); 
_debugfile<<endl; 
}
*/ 
/*
_debugfile<<"Reduced residual vector:"<<endl;  
for(int i=0;i<3*_numberofnodes;i++)
_debugfile<<_fi[i]<<endl; 
*/

};


void gausselim(double rhs[],double** K,int numberofdatapoints,ofstream& outfile,Node nodes[], double du[])
{
  double** M=new double*[numberofdatapoints]; 

	for (int i = 0; i < numberofdatapoints; i++) 
	{
		du[i]=rhs[i]; 
		M[i]=new double[numberofdatapoints];
		for (int j = 0; j < numberofdatapoints; j++) 
		{
		M[i][j]=K[i][j]; 
		}
	}
	
	// LU decomposition without pivoting 
  for (int k = 0; k < numberofdatapoints - 1; k++) {
    if (M[k][k] == 0) 
      cout<<"pivot is zero in Mtx::GaussElim()"<<endl;
    for (int i = k + 1; i < numberofdatapoints; i++) {
      if (M[i][k] != 0) {   // M[i][k] can be complex
        double mult = M[i][k]/M[k][k];
        M[i][k] = mult;
        for (int j = k + 1; j < numberofdatapoints; j++) 
          M[i][j] = M[i][j]-mult*M[k][j];
      }
    }
  }

  // forwad substitution for L y = b. y still stored in rhs
  for (int i = 1; i < numberofdatapoints; i++) 
  for (int j = 0; j < i; j++) du[i] =du[i]-M[i][j]*du[j];

  // back substitution for U x = y. x still stored in rhs
  for (int i = numberofdatapoints - 1; i >= 0; i--) {
  for (int j=i+1; j<numberofdatapoints; j++) du[i] = du[i]-M[i][j]*du[j];
  du[i] =du[i]/ M[i][i];
  }

	
  //outfile<<endl; 
  //outfile<<"nodal displacement vector:"<<endl; 
  for(int i=0;i<numberofdatapoints;i++)
  {
	  nodes[i/3].u[i%3]=nodes[i/3].u[i%3]+du[i];
	  /*
	  if(i%3==0)
	  {
          nodes[i/3].u[0]=nodes[i/3].u[0]+du[i];
	  //nodes[i/3].X[0]=nodes[i/3].X[0]+du[i];
	  //outfile<<"ux of node"<<i/2<<du[i]<<endl;
	  }
	  else if(i%3==1)
	  {
          nodes[i/3].u[1]=nodes[i/3].u[1]+du[i];
	  //nodes[i/3].X[1]=nodes[i/3].X[1]+du[i];
	  //outfile<<"uy of node"<<i/2<<du[i]<<endl;
	  }
 
	  else if(i%3==2)
	  {
          nodes[i/3].u[2]=nodes[i/3].u[2]+du[i];
	  //nodes[i/3].X[2]=nodes[i/3].X[2]+du[i];
	  //outfile<<"uy of node"<<i/2<<du[i]<<endl;
	  }
  	  */ 
  }


for(int i=0;i<numberofdatapoints;i++)
delete[] M[i]; 
delete[] M; 


};



void du_copy(double du[],double du_prev[],ofstream& debugfile,int numberofnodes)
{
for(int i=0;i<3*numberofnodes;i++)
du_prev[i]=du[i]; 
}; 



void fullincrementalforcevector(Node nodes[],double incrementalforcevector[], double du[],
				double** Kglobal, double numberofiterations,
				double& ltwoinitialfi, double l, ofstream& debugfile, int numberofnodes)
{
if(numberofiterations<1.0)
{
for(int i=0;i<3*numberofnodes;i++)
{
if(l==0)
incrementalforcevector[i]=0.0;
for(int j=0;j<3*numberofnodes;j++)
incrementalforcevector[i]=incrementalforcevector[i]+Kglobal[i][j]*du[j];  
}
ltwoinitialfi=eulernorm_residual(incrementalforcevector,numberofnodes);
} 

for(int i=0;i<3*numberofnodes;i++)
if(nodes[i/3].natural_bc[i%3]==1.0)
incrementalforcevector[i]=0.0;

};

double eulernorm_residual(double fi[],int numberofnodes)
{
double norm=0.0;
for(int i=0;i<3*numberofnodes;i++)
norm=norm+fi[i]*fi[i];

return sqrt(norm); 
};  


double error_indu(double du[],double du_prev[],ofstream& debugfile,int numberofnodes)
{
double max;
double maxprev;  

double norm_du=eulernorm_residual(du,numberofnodes);
double norm_du_prev=eulernorm_residual(du_prev,numberofnodes);

/*
for(int i=0;i<12;i++)
{
maxprev=fabs(du[i]/du_prev[i]); 
if(i==0)
max=maxprev; 
if(maxprev>max)
max=maxprev; 
}
return max; 
*/ 
//cout<<"norm_du: "<<norm_du<<endl;
//cout<<"norm_du_prev: "<<norm_du_prev<<endl;
//return fabs(norm_du-norm_du_prev)/norm_du_prev; 
return norm_du/norm_du_prev; 
}; 


double det(double a[][3])
{
double result=0.0;
result=a[0][0]*(a[1][1]*a[2][2]-a[2][1]*a[1][2])-
       a[0][1]*(a[1][0]*a[2][2]-a[2][0]*a[1][2])+
       a[0][2]*(a[1][0]*a[2][1]-a[2][0]*a[1][1]);

return result;


};

double trace(double tens[3][3])
{
double result=0.0; 

for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
if(i==j)
result=result+tens[i][j]; 

return result; 



}; 

void matrix_product(double tens1[3][3],double tens2[3][3],double result[3][3])
{
for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
result[i][j]=0.0; 

for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
for(int k=0;k<3;k++)
result[i][j]=result[i][j]+tens1[i][k]*tens2[k][j]; 
}; 


void transpose(double tens[3][3], double tens_T[3][3])
{
for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
tens_T[i][j]=tens[j][i]; 
}; 

double cronecker(int i,int j)
{
double result; 
if(i==j)
result=1.0; 
else 
result=0.0; 
return result; 

}; 

double symmetry_tensor(int i,int j, int k, int l)
{
double result;
result=0.5*(cronecker(i,k)*cronecker(j,l)+cronecker(i,l)*cronecker(j,k));
return result;
};

void inverse(double tens[3][3], double inv_tens[3][3])
{
inv_tens[0][0]=tens[1][1]*tens[2][2]-tens[2][1]*tens[1][2];
inv_tens[0][1]=tens[0][2]*tens[2][1]-tens[2][2]*tens[0][1];
inv_tens[0][2]=tens[0][1]*tens[1][2]-tens[1][1]*tens[0][2];


inv_tens[1][0]=tens[1][2]*tens[2][0]-tens[2][2]*tens[1][0];
inv_tens[1][1]=tens[0][0]*tens[2][2]-tens[2][0]*tens[0][2];
inv_tens[1][2]=tens[0][2]*tens[1][0]-tens[1][2]*tens[0][0];


inv_tens[2][0]=tens[1][0]*tens[2][1]-tens[2][0]*tens[1][1];
inv_tens[2][1]=tens[0][1]*tens[2][0]-tens[2][1]*tens[0][0];
inv_tens[2][2]=tens[0][0]*tens[1][1]-tens[1][0]*tens[0][1];




for(int i=0;i<3;i++)
for(int j=0;j<3;j++)
inv_tens[i][j]=inv_tens[i][j]/det(tens); 

};





int node_counter(ifstream &_nodes_infile, int &_numberofnodes)
{
_numberofnodes=0;
char current_line[256];
_nodes_infile.getline(current_line,256);
int condition=0;
while(condition==0)
{
_nodes_infile.getline(current_line,256);
//cout<<current_line<<endl;
if(current_line[1]=='N' && current_line[2]=='O' && current_line[3]=='D' && current_line[4]=='E')
condition=1; 
}
_nodes_infile.getline(current_line,256);

while(current_line[0]!='*')
{
_nodes_infile.getline(current_line,256);
_numberofnodes++;
}


cout<<"The number of nodes in your model: "<<_numberofnodes<<endl;



return 0;
}

int element_counter(ifstream &_elements_infile, int &_numberofelements)
{
_numberofelements=0;
char current_line[256];
_elements_infile.getline(current_line,256);
int condition=0;
while(condition==0)
{
_elements_infile.getline(current_line,256);
//cout<<current_line<<endl;
if(current_line[1]=='E' && current_line[2]=='L' && current_line[3]=='E' && current_line[4]=='M' 
&& current_line[5]=='E' && current_line[6]=='N' && current_line[7]=='T')
condition=1; 
}
_elements_infile.getline(current_line,256);

while(current_line[0]!='*')
{
_elements_infile.getline(current_line,256);
_numberofelements++;
}


cout<<"The number of elements in your model: "<<_numberofelements<<endl;



return 0;
}


void result_writer(Node _nodes[], Element _elements[],
                  int _numberofnodes, int _numberofelements)
{


ofstream resultfile("example_result.inp");
resultfile<<"*NODE"<<endl;

double scale=1.0;

for(int n=0;n<_numberofnodes;n++)
{
/*
resultfile<<_nodes[n].nodelabel<<','<<setw(10);
resultfile<<_nodes[n].X[0]<<','<<setw(10);
resultfile<<_nodes[n].X[1]<<','<<setw(10);
resultfile<<_nodes[n].X[2]<<endl;
*/

resultfile<<_nodes[n].nodelabel<<','<<setw(10);
resultfile<<(_nodes[n].X[0])+scale*_nodes[n].u[0]<<','<<setw(10);
resultfile<<(_nodes[n].X[1])+scale*_nodes[n].u[1]<<','<<setw(10);
resultfile<<(_nodes[n].X[2])+scale*_nodes[n].u[2]<<endl;

}
resultfile<<"**"<<endl;



resultfile<<"*ELEMENT, TYPE=C3D8, ELSET=solids_example"<<endl;

for(int e=0;e<_numberofelements;e++)
{
resultfile<<_elements[e].elementlabel<<','<<setw(10);
for(int c=0;c<7;c++)
resultfile<<_elements[e].conname[c]<<','<<setw(10);
resultfile<<_elements[e].conname[7]<<endl;
}

resultfile<<"**"<<endl;

};



void odb_result_writer(Node _nodes[], Element _elements[],
                       int _numberofnodes, int _numberofelements)
{

    odb_String name("simpleModel");
    odb_String analysisTitle("ODB created with C++ ODB API");
    odb_String description("example illustrating C++ ODB API");
    odb_String path("result.odb");
    odb_Odb& odb = Odb(name,
                       analysisTitle,
                       description,
                       path);


cout<<"it seems to be it is saving"<<endl;
/*
  odb_Part& part1 = odb.Part("part-1",
       odb_Enum::THREE_D, odb_Enum::DEFORMABLE_BODY);



//writing the model data: nodes
  odb_SequenceInt nodeLabels;

for(int n=0;n<_numberofnodes;n++)
{
nodeLabels.append(_nodes[n].nodelabel);
}

  odb_SequenceSequenceFloat nodeCoor;
  for (int n=0; n<nodeLabels.size(); n++) {    
    odb_SequenceFloat loc;
    for (int i=0; i<3; i++)
      loc.append(_nodes[n].X[i]);
    nodeCoor.append(loc);
  }
  part1.addNodes(nodeLabels, nodeCoor, "Nodes");

//writing the model data: elements 
  odb_SequenceInt elLabels;

for(int e=0;e<_numberofelements;e++)
elLabels.append(_elements[e].elementlabel);

  odb_SequenceSequenceInt connect;
  const int numNodePerEl = 8;
  for (int e=0; e<elLabels.size(); e++) {
    odb_SequenceInt l;
    for (int i=0; i<numNodePerEl; i++)
      l.append(_elements[e].conname[i]);
    connect.append(l);
  }
	
    odb_String sectionCategoryName("C3D8");
    odb_String sectionCategoryDescription("my_hexahedras");
    odb_SectionCategory& sCat =
        odb.SectionCategory(sectionCategoryName,
                            sectionCategoryDescription);


  part1.addElements(elLabels, connect, "C3D8",
		    "Hexahedras",sCat);

odb.save();
odb.close();
*/
/*

ofstream resultfile("example_result.inp");
resultfile<<"*NODE"<<endl;

double scale=1.0;

for(int n=0;n<_numberofnodes;n++)
{


resultfile<<_nodes[n].nodelabel<<','<<setw(10);
resultfile<<(_nodes[n].X[0])+scale*_nodes[n].u[0]<<','<<setw(10);
resultfile<<(_nodes[n].X[1])+scale*_nodes[n].u[1]<<','<<setw(10);
resultfile<<(_nodes[n].X[2])+scale*_nodes[n].u[2]<<endl;

}
resultfile<<"**"<<endl;



resultfile<<"*ELEMENT, TYPE=C3D8, ELSET=solids_example"<<endl;

for(int e=0;e<_numberofelements;e++)
{
resultfile<<_elements[e].elementlabel<<','<<setw(10);
for(int c=0;c<7;c++)
resultfile<<_elements[e].conname[c]<<','<<setw(10);
resultfile<<_elements[e].conname[7]<<endl;
}

resultfile<<"**"<<endl;
*/
};
